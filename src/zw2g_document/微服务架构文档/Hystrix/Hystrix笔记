实现容错的原因
   当微服务所依赖的服务不可用时，大量的请求，大量的并发不做任何处理的等待，会耗尽系统的资源，拖垮自身的服务

容错原因
    微服务架构通常包含了多个服务层，微服务之间通过网络进行通信，从而支撑起整个应用系统
    当发生基础服务故障的时候，可能会导致生产者A的消费者B无法调用，从而导致需要调用消费者B的消费者C和D都无法
调用，导致不可用逐渐放大
    线程请求的对象得不到销毁，很多依赖的服务异常发生延时，超时等情况的时候，线程得不到释放，就会一直占用系统资源(内存)

缓存雪崩
    缓存层发生故障，数据完全面向数据库

如何容错
    防止产生雪崩效应的手段就是要有一个强大的容错机制
    1:为网络请求设置超时
        当一个网络相应非常缓慢，就意味着一个线程资源得不到及时的释放，线程资源又对应着服务器资源，
    大量的服务器资源被占用得不到释放，就会导致服务的不可用，所以需要为网络设置超时，尽快释放服务器资源，
    一次http请求需要得到服务器的响应才会断开连接，否则不会断开连接，微服务之间的调用，将会大大消耗服务器资源
    2:使用断路器模式
        断路器模式可以理解为对访问服务出错时候的代理，当请求对服务的访问发生大量失败时将打开断路器，断路器会
    对失败的次数进行判断，来选择是否需要继续对服务进行访问，并对访问出错的服务进行快速失败
        断路器也可以自动诊断依赖的服务是否已经恢复正常，如果发现依赖的服务已经恢复了正常，那么将会恢复对该服务的
    请求，该机制保证了在微服务挂掉的情况下快速失败，防止雪崩，当服务恢复以后，又可以重新对服务发送请求

断路器原理
    断路器关闭->请求失败率达到一定的阈值->断路器打开(不会在请求依赖的服务)->一段时间，断路器半开(允许少量的请求)
    ->请求失败，断路器继续打开->成功，断路器关闭



Hystrix
    1:实现超时机制和断路器模式的工具
      Hystrix具备了服务降级、服务熔断、线程隔离、请求缓存、请求合并以及服务监控等强大功能。
    1-1:包裹请求-使用hystrixCommand包裹对依赖的调用逻辑，每个命令在独立的线程中执行，可以设置线程池的大小
    1-2:跳闸机制-当错误率达到了一定的程度，Hystrix会自动或者手动停止请求该服务一段时间
        --Q:如何实现自动或是手动跳闸
    1-3:资源隔离
        -Hystrix为每个依赖都维护了一个线程池(或是信号量)，当请求数量达到线程池数量，就会立即拒绝请求，
        此处的隔离指的是将请求线程和执行线程进行隔离，优点算是可以立即释放请求线程，让请求线程处理更多的
        请求，也算是异步编程吧，可以很好的提高系统对请求的执行效率，缺点就是增加了服务器的cpu调度和线程
        的上下文切换
    1-4:监控
        -Hystrix提供了图形化的监控工具，从而监控整个服务请求调用的情况
    1-5:回退机制-当请求失败，超时，被拒绝的时候，执行回退逻辑
    1-6:自我修复

2~3:Hystrix熔断器执行机制
https://www.jianshu.com/p/d978126bc1af
Hystrix为每个commandKey维护了一个熔断器，为了避免并发操作导致的不安全性，使用ConcurrentHashMap集合进行保存

2:Hystrix实现熔断原理
    Hystrix熔断器有三个状态，OPEN,CLOSE,HALF-OPEN,当触发熔断的时候，熔断器状态变为OPEN,过一段时间Hystrix
    会放出请求检测服务是否开启，这期间熔断器会变更状态为HALF-OPEN,如果服务可用了则变更为CLOSE

3:如何判定Hystrix开启熔断
    在源码中对Hystrix进行订阅操作，当数据发生变化的时候执行下面处理逻辑
    3-1判断当前请求量有没有达到设定量
    3-2判断发生错误的数量有没有达到阈值，达到阈值则将熔断设置为OPEN


4:Feign通过配置文件可开启熔断器
    feign.hystrix.enabled=true


5:hystrix请求缓存/合并请求
hystrix为了应对高并发操作，可以使用缓存和请求合并来缓解服务器的压力
5-1:请求缓存是对一次请求的数据进行缓存，当有新的请求进来的时候，将会进行初始化操作，保证读取到的数据是最新的而不是
上次缓存的数据
Q:如果只是缓存一个请求下的数据，那缓存的意义是什么，获取到的数据又不需要重查一次
A:请求缓存如果能够配合请求合并一起使用，将会大大提高并发的效率，否则是比较鸡肋的功能
...请求合并是获取一段时间内的请求参数，通过指定的方法进行统一处理，所以此处是无法和请求缓存一起使用
5-1:请求缓存用到三个注解
@CacheResult:将方法标记为缓存方法，表示给这个方法开启缓存功能，方法传递的参数为cache的key值
@HystrixCommand(commandKey = "commandKey2")
@CacheKey:指定缓存的key值

M1:在开发过程中，当我把注解加载在feign接口上的时候，注解是不起作用的
M2:将调用service放在控制层，缓存不起作用
M3:将缓存方法放入service方法中，再由service方法请求feign接口，缓存成功

5-2:请求合并是对单个接口的多次调用合并成一次统一的调用，由消费者发起一次统一的对提供者的服务请求
，返回的结果在依次封装进原request的相应体内
使用请求合并的优点就是在高并发的场景下降低服务器的压力，缺点也很明显，对于并发不够的反而会减慢服务
返回的速度
架构:请求合并主体架构分为两块，一块是请求合并处理，一块是对请求进行批量处理

M1:开发过程中发现请求失败，原因是feign注解无法使用@RequestParam传参这种类型




hystrix使用概括
https://blog.csdn.net/beyond59241/article/details/73719137
*hystrix理解*
https://www.jianshu.com/p/e3408619718d
hystrix基础相关博客
https://www.cnblogs.com/zuowj/p/10418932.html
hystrix请求缓存相关博客
https://www.cnblogs.com/hellxz/p/9056806.html
hystrix请求合并相关博客
https://www.cnblogs.com/hellxz/p/9071163.html
https://www.cnblogs.com/happyflyingpig/p/8136450.html

