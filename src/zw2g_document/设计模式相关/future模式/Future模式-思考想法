1-关于Jdk实现的future模式和设计模式中的有什么差别
两者的本质应该是一样的，实现原理应该是相通的，大方向上都是返回一个没有数据的契约，在通过代码本身去起一个线程去获取数据，
当数据获取到后，再把放数据的实体装载到契约类中，由契约类调用
在设计模式当中，契约类是futureData，实际数据类是realData



Q1：在jdk实现的future设计模式中，futureTask就是对应futureData类，那么怎么实现realData类的功能，重新启动的客户端线程是如何实现的
A1：future类实现了对实际数据的调用工作，可通过future获取调用实际数据结果，futureTask是future的实现，实际futureTask就是future，
就是futureData

***Q2：如何实现将realData中的数据放入到future当中，如何获取的实际数据？
***A2：在构造future对象的时候，需要传入callback类对象作为参数(实际是编写realData类，实现Callback接口),一旦运行(执行run方法)，就执行给定的
***callable(执行run方法后，会调用callable类中的call方法)，然后返回callable对象，产生结果后，调用set方法写进futureTask类，获取数据
***的时候执行get方法就可以获取到set进futureTask中的result数据



2-FutureTask基本数据结构构成和组成成分关系理解
FutureTask实现了RunnableFuture，RunnableFuture又继承了runnable类和future类，实现runnable的目的是可以将futureTask
提交给execute进行执行，作为runnable的future，成功执行run方法可以完成future，并允许他访问其结果,future提供了异步结果的访问

3-RunnableFuture类执行逻辑
RunnableFuture类在执行完run方法后完成future,futureTask实现了RunnableFuture类，那么futureTask实现了run方法后，提交给
execute进行执行


4-FutureTask数据结构组成
FutureTask可以被用作包着runnable或是Callable的对象，futureTask可以被execute执行

4-1:Callable作用
Callback作用类似于runnable，都是实现了对异步调用的执行方法，区别是runnable不会返回异步调用的结果，但是callback可以返回异步调用结果
自定义类需要实现calllable方法，并重写call方法，实现异步事件的计算，相当于realData类的功能


5:FutureTask实现realData功能
在构建FutureTask类的时候，需要传递参数，调用构造方法，内部实现则是，对传入的构造参数重新启动线程(执行run方法)，在run方法中会调用callable
实现类的call方法，获取返回的执行数据，然后调用set方法将数据存入futureData中，调用futureTask的get方法可以获取到存入的执行数据

Q3:在futureData调用回调函数的时候，是在哪里启动的线程
A3:在构造futureData后，会通过Executors方法创建ExecutorService，然后执行futureTask



=========================================================================================


future模式
1客户端发起请求-->服务端返回客户端一个契约-->客户端继续执行其余任务-->在完成了其他与数据无关的任务后，在使用利用空余时间返回的数据。。。
-->充分利用时间，提高效率-->future模式的核心


future主要特色
main-->主类，用于系统启动，调用Client发出请求
Client-->返回data数据，立即返回futureData，并开启ClientThread装载
data-->返回数据的接口
futureData-->构造较快，返回临时契约，是虚拟的数据，需要装载realData
realData-->返回真实数据，构造比较慢



设计模式实现类

产生真实数据步骤
    1-main类:主类，运行相关方法,向client类发出请求，返回data(实则为futureData)
    2-Client类:主方法请求该类，返回一个data数据，这时候返回的是futureData，并不是真实数据，同时会异步发出请求去获取真实数据...
    并将最终realdata数据装载进futureData，主类在进行调用
    3-realData类:构造执行相应的方法，得到实际数据
    4-future类:装载realData类


获取真实数据步骤
    1-main类:通过方法返回的data数据，调用future类，获取future装载的realData数据
    2-future类:调用realData类方法获取真实数据
    3-realData类:返回真实数据




=============================Future模式在源码中的实现BEGIN=====================================

jdk中实现类:
    futureTask：实现了runnableFuture方法，runnableFuture方法继承了runnable方法和future方法，

====================================================================================================
总结:
    主要思路是通过异步的方式实现程序对未来数据的获取，比如说
    线程A的执行需要B的结果，但是实际上A并不需要等待B执行完，而是先获取一个B的future，等待将来的某个时候获取B的数据


=============================QUESTION=====================================
Q1:服务端返回给客户端的契约是什么
A1:返回的契约就是futureData数据，实际上并没有获取真实数据

Q2:往future类中装载的realData到底有什么作用
A2:一方面修改状态，提示后面可以进行获取操作，一方面可以使用装载得到的realdata数据获取得到真实数据

Q3:如何得知实际数据已经完成了呢
A3:调用获取实际数据的方法，如果数据已经装载成功则直接返回数据，否则进入await

Q4:future接口和futureTask的关系
A4:futureTask实现了RunnableFuture接口，RunnableFuture接口继承了runnable类和future类

=============================ANSWER=====================================
参考文章:
demo源码和jdk源码
https://blog.csdn.net/xlgen157387/article/details/78390642

future设计模式的核心关键点:
https://blog.csdn.net/yangkai_hudong/article/details/12904813









