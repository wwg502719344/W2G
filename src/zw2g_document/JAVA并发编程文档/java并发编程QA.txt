java并发编程基础原理

    Q1:多线程与并发的关系
    A1:多线程不等与并发，多线程仅仅是一种提高CPU使用的手段，作用就是使CPU的使用率达到最大化，
    多线程可以更加高效的处理并发的请求

    Q2:两种猜想，基于高并发
    A2:基于http请求，多线程由servlet容器完成，单线程下的多线程只是为了处理业务功能或IO密集(我认为是对的)
    A2:多线程由servlet容器实现，java多线程用于提高并发能力，因为是单例，所以代码中的多线程用于
    应对HTTP请求的高并发，实现CPU的利用率(前面一般是对的，业务中的多线程不是为了应对高并发，和单例无关)

    Q3:基于多线程的猜想
    A3:单个http请求，触发多线程代码，实际服务器触发多少线程(实际服务器触发的就是业务代码中的线程数，只不过这种线程并不是为了处理高并发，而是为了处理相关的业务逻辑)

    Q4:基于单例模式下的高并发猜想
    A4:每一个请求对应一个线程，多用户访问同一个方法时，每个方法生成独立的栈桢，不存在并发问题，只用设计成员
    变量的时候才会设计(不完整，如果在查询过程中查到同样的数据，然后进行操作，也会出现并发问题)

    Q5:java工作内存的数据和栈桢中的数据以及堆中的数据是什么关系
    A5:java工作内存中保存的应该是拷贝复制的共享变量的值，而战争中的局部变量表中保存的是堆中数据的引用

    Q6:volatile变量和普通变量之间的重排序可能会破坏volatile的内存语义，什么意思
    A6:其实就是破坏了内存可见性，本来没有数据关联的两个操作做了重排序，可能会导致另一个线程读取的数据有误



