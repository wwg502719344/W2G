===========================================QUESTION======================================================
Q1:DelayQueue队列为什么要使用ReentrantLock来实现队列的加锁问题


Q2:集合内部的元素怎么实现接口？比如DelayQueue<E extends Delayed>，指的就是内部元素实现了Delayed接口


Q3:队列中的可用元素是在延迟期到了才加入到队列中的，还是一直都在队列中，只有延迟期时间到了才会唤起调用线程


Q4:leader-follower模式中，leader线程和follower线程作用到底体现在哪里，在哪里用到了，具体的使用场景是什么


Q5:在leader-follower模式中，我发现在调用等待队列的signal方法的时候，都会把leader置为空，为什么，其次，leader的赋值
是在什么场景下，目前只在take方法中发现赋值，还是将当前线程设置为leader，这肯定是和该设计模式原理不相符合的


Q6:当有一个新的事件产生的时候，leader线程就会通知产生新的leader，自己去干活，问题是这个leader在什么时候去干活，怎么去干活？..
处理事件和take源码中获取n元素有什么关系？是否是获取元素后，leader去处理接下来的操作，但是源码中是直接返回元素，要leader做什么呢？

===========================================QUESTION======================================================





===========================================ANSWER======================================================
A1:


A2:元素在加入到DelayedQueue队列中的时候，元素本身应该是实现了Delayed的类，这样才能加入到队列中来


A3:延迟队列中的元素一直都在延迟队列中，但是如果延迟时间没有到，是无法调用返回的，只有时间到了才会返回队列中的元素


A4:


A5:首先说下Condition方法的await方法和signal这两个方法，
await方法是将当前线程包装成一个节点，加入到等待队列中去
signal方法就是将等待队列中等待最久的那个节点加入到同步队列中去


A6:
在整个调用关系中，只有leader一直在进行循环试图返回元素(什么时候干，干什么的问题)，
处理事件其实就是返回元素，在take方法中，leader一直在试图将元素返回
但是如果当别的线程获取锁后，也是可以直接返回这个即将过期的元素的
当leader返回过期元素后，自身会唤醒等待队列中的等待线程
参考资料:
https://bigbully.github.io/DelayQueue
===========================================ANSWER======================================================