1-并发环境下为什么使用ConcurrentHashMap

    1-1：
        java7中HashMap在高并发的情况下，通过put操作会导致HashMap的entry链表形成环链，
    从而造成entry的next节点用不为空因而产生死循环

    1-2:
        Unsafe类:java不能直接访问操作系统底层，而是通过native方法来访问，Unsafe提供了硬件级别的原子操作
    (有空研究源码)
        1-2-1：分配内存，释放内存
        1-2-2：可以定位对象字段的内存位置，也可以修改字段值
        1-2-3：挂起与恢复-LockSupport中的park方法也是调用了Unsafe.park()
        1-2-4：CAS操作

2-ConcurrentHashMap调用put方法源码解析
    首先校验数据，然后根据key值的hashCode计算出hash值(获得hash值和i通过计算可以获取其tab[i]的数据)，然后对传入参数进行操作
    操作步骤如下:
        步骤1:查看tab是否为null，如果为空则进行初始化操作
        步骤2:查看tab[index]位置是否为空，如果为空，则将数据直接插入，并退出
        步骤3:如果链表正在进行扩容操作，则帮助其进行扩容
        步骤4:找到对应的tab[index]节点，对操作进行加锁处理并存储数据，操作如下
        步骤4-1:如果该节点是链表节点，则判断该链表中是否有相同的key值，有则更新，无则新增
        步骤4-2:如果首节点是树节点，则新增一个节点
        步骤5:检查，如果链表结构中节点数量多于8个，则将链表结构转变为树结构

3-链表结构转变为红黑树
    在步骤5中，如果链表结构的节点数量超出指定的数量，将会由链表结构转变为树结构，链表转树结构如下
    步骤一:
