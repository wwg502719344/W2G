所属类名:    W2g_AQS
涉及源码:    P1,P1-1,P1-2,P3,P3-1


流程梳理:
    1:线程调用acquire尝试获取锁资源，如果获取失败，则将线程挂起，加入等待队列中
        1-1:如果没有获取到同步资源且acquireQueued方法返回true，说明该线程在被挂起的时候被中断过，此时当前线程会自己进行中断操作。。。
        在acquireQueued方法中调用，parkAndCheckInterrupt()的时候返回true(自我检查)，此时中断标记位就会被标记位被中断
        1-2:被挂起的线程被中断的话是不会感应到中断操作的，只有被唤起的时候才会进行自检是否被中断过
    2:调用acquireQueued方法，该方法目的是获取同步资源并将当前节点指向首节点,如果无法获取同步资源,则将当前线程挂起,主要根据不同情况作了两种处理
        1自旋获取锁的过程，如果该节点的前驱节点是首节点且获取锁资源成功，就将当前节点设置为首节点，但是首节点线程为null,目前只是将...
        首节点设置为当前节点，并且从这个方法中退出
        2调用shouldParkAfterFailedAcquire方法，如果当前节点的前驱节点是可唤醒节点，则返回true，代表前驱节点仍可唤起，也说明。。。
        当前节点的前驱节点不是首节点，所以需要被挂起，否则清除当前节点之前已取消的节点，使当前节点的前驱节点变成首节点

===========================================共享模式=============================================================

    3:获取锁资源(基于共享模式)
        1:线程调用acquireShared方法，内部调用tryAcquireShared方法尝试去获取共享资源，获取成功则不需要进入等待队列，
        失败则需要进入等待队列中被构造成节点加入到等待队列的尾部
        2:在doAcquireShared方法中，将当前线程构造成节点，
            0特别注意，当线程被构造成节点的时候，如果是第一个节点，则会创建一个空的节点作为首节点，当前节点是尾节点的后继节点。。。
            (首节点代表了获取同步资源的节点，当等待队列为空的时候，创建的首节点正代表了获取同步资源的线程)

            1如果前驱节点是首节点，会尝试获取同步资源，如果获取成功，则将当前节点设置为首节点并释放挂起的当前节点

            2如果不具备获取同步状态的条件，则调用shouldParkAfterFailedAcquire
                2-1:如果当前节点的前驱节点是可被唤醒的，则返回true，将当前线程挂起
                2-2:如果当前节点的前驱是已取消节点，则删除那些已取消节点，并返回false，继续进行自旋
                2-3:否则可以判断出当前节点的状态为0或PROPAGATE,此时将当前节点的前驱节点的状态改为可被唤醒状态，返回false，。。。
                继续进行自旋尝试获取资源

    4:调用资源释放(基于共享模式)
        调用tryReleaseShared方法，更改AQS对象state线程的状态，更改状态成功，调用doReleaseShared方法释放内存中挂起的线程,并唤起下一个节点
        3-1:releaseShared方法:(P3)
            3-1-1:调用releaseShared()方法，释放当前线程，在state>0的情况下(有可释放的线程),tryReleaseShared方法返回true，进入下一步
            3-1-2:调用doReleaseShared方法，该方法主要的作用是释放首节点并唤起后继结点
        3-2:doReleaseShared方法(P3-0):
            首先是获取首节点元素，并判断是否是唯一的，如果有后继节点且等待节点的状态是等待触发的，就将当前节点的状态改为0，并释放后继结点(...
            首节点元素是不需要唤起的)，如果首节点的状态已经是0，那么就将状态改为可传播的状态


线程访问流程:
    假定我们有10个资源，A线程正在占用7个，B线程正在占用2个，剩余1个资源,线程C需要2个资源，获取资源失败
    1:等待队列无节点，会被加入到同步队列中，构造成节点，这时候head节点设为空节点，tail的next都指向当前节点，然后再次尝试获取资源。。。
    获取成功，则再次将首节点指向自己，调用doReleaseShared方法，当发现尾节点也是首节点的时候，会直接break，结束流程

    2:等待队列有节点，加入同步队列，构造成节点，成为尾节点，获取当前节点的前驱节点，此时有两种情况
        2-1:前驱节点不是首节点，调用shouldParkAfterFailedAcquire方法，查看前驱节点状态，
            1:如果前驱节点是可被唤起的则返回true，挂起当前线程
            2:如果前驱节点状态是取消，则一直往前清除无效的前驱节点，直到前驱节点状态有效，返回false继续进入自旋重复过程
            3:如果前驱节点是其他状态，waitStatue改为SIGNAL并返回false，继续自旋重复过程
        2-2:此时前驱节点是首节点，再次尝试获取同步状态，获取成功，将头结点指向当前节点，如果同步队列中只有一个节点，则结束，。。。
        如果同步队列中不止一个节点，
        1当前驱节点的waitStatus是SIGNAL时，将首节点的waitStatus改为0，然后唤起首节点当后继节点（有效节点），。。。
        2如果waitStatus是0，则将waitStatus改为PROPAGATE，






