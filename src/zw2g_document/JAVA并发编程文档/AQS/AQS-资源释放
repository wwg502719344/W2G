所属类名:    W2g_AQS
涉及源码:    P1,P1-1,P1-2,P3,P3-1


流程梳理:
    1:线程调用acquire尝试获取锁资源，如果获取失败，则将线程挂起，加入等待队列中
        1-1:如果没有获取到同步资源且acquireQueued方法返回true，说明该线程在被挂起的时候被中断过，此时当前线程会自己进行中断操作。。。
        在acquireQueued方法中调用，parkAndCheckInterrupt()的时候返回true(自我检查)，此时中断标记位就会被标记位被中断
        1-2:被挂起的线程被中断的话是不会感应到中断操作的，只有被唤起的时候才会进行自检是否被中断过
    2:调用acquireQueued方法，该方法目的是获取同步资源并将当前节点指向首节点,如果无法获取同步资源,则将当前线程挂起,主要根据不同情况作了两种处理
        1自旋获取锁的过程，如果该节点的前驱节点是首节点且获取锁资源成功，就将当前节点设置为首节点，但是首节点线程为null,目前只是将...
        首节点设置为当前节点，并且从这个方法中退出
        2调用shouldParkAfterFailedAcquire方法，如果当前节点的前驱节点是可唤醒节点，则返回true，代表前驱节点仍可唤起，也说明。。。
        当前节点的前驱节点不是首节点，所以需要被挂起，否则清除当前节点之前已取消的节点，使当前节点的前驱节点变成首节点

    3:调用资源释放(基于共享模式)
        调用tryReleaseShared方法，更改AQS对象state线程的状态，更改状态成功，调用doReleaseShared方法释放内存中挂起的线程,并唤起下一个节点
        3-1:releaseShared方法:(P3)
            3-1-1:调用releaseShared()方法，释放当前线程，在state>0的情况下(有可释放的线程),tryReleaseShared方法返回true，进入下一步
            3-1-2:调用doReleaseShared方法，该方法主要的作用是释放首节点并唤起后继结点
        3-2:doReleaseShared方法(P3-0):
            首先是获取首节点元素，并判断是否是唯一的，如果有后继节点且等待节点的状态是等待触发的，就将当前节点的状态改为0，并释放后继结点(...
            首节点元素是不需要唤起的)，如果首节点的状态已经是0，那么就将状态改为可传播的状态





