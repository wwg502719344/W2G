(一) 基于jdk1.7的hashmap基本结构
在1.7之前，hashmap是采用数组+链表的结构进行数据的存储，为什么要使用链表而不是全使用数组呢，
因为map是通过计算hash值来决定元素位置的，如果key值不同而hash相同，就会被构造成链表的形式
所有此处需要注意，不同的key的hash是可以相同的，同一个链表下的节点hash值都是相同的


hashmap线程不安全的两种原因
1.多线程下导致put操作的覆盖
线程A和线程B对HashMap进行put操作，当线程A通过hashcode计算出数组下标的位置，通过hash计算
出链表的位置，这时候线程A的时间片用完了，线程B也开始执行，成功插入位置，这时候线程B将线程A的node
覆盖，造成数据的丢失
2.多线程下导致环链的产生
    do {
        Entry<K,V> next = e.next; // <--P1-假设线程一执行到这里就被调度挂起了
        int i = indexFor(e.hash, newCapacity);
        e.next = newTable[i];
        newTable[i] = e;
        e = next;
    } while (e != null);
上面为put操作发生扩容时候的操作
在这里我不详细阐述环链的产生过程，我想关注的是产生这种现象的原因及内部的重要机制
首先为什么会产生环链，在单线程下的扩容，hashmap采用头插式的方式将链表的节点转移到新的数组上，
头插式就是从原数组数组位置的node加载进新的数组节点位置，链表的后继节点依次重新将后继节点指向
当前占据数组位置的节点，再重新占据数组位置节点成为头结点，依次下去，链表位置重新移动到数组上
，但是链表的位置全部反过来了

简单点说就是原节点A->B->C,使用扩容后的型数组原理则是将原数组B节点指向扩容后的A节点，再将扩容
后的数组指向B节点，从而达到节点的倒插，新数组的结构是C->B->A，但是在博客中发现最后一个节点C
会安插到别的数组位置，原因可能是数组扩容后会重新计算新的位置

多线程情况下会导致循环
当其中一个线程的时间段用尽后，另一个线程完成了数组的扩容，这里需要特别注意的是，
原数组此时为空，线程1在P1中的e及next重新指向了线程2扩展后的数组，此时使用头插式继续，将会
导致环链的形成


3.多线程下的值丢失
主要是因为在扩容过程中新数据插入到不同的数组位置中，导致next的缺失，最终没有把next指向之前指向
自己的那个节点，导致next为空，丢失数据


(二)基于jdk1.8的扩容
1核心思想:需要注意的是索引位置的变化，在1.8中通过利用哈希桶长度的变化，每个hash值对应的索引值发生改变，0和1的变化
0的则保持位置不变，1则当前索引加上oldlength
2具体操作:将新扩建的数组分为高位和低位，并建立相关的链表高低位局部变量，通过判断是否需要移动索引来分配具体的数组位置
好处就是减少了hash的在生成，环链的问题得到解决

hash算法
hash算法是计算key值对应hash桶的位置，即索引，就是key值对应的所在数组的位置

参考资料
1-JAVA HASHMAP的死循环
https://coolshell.cn/articles/9606.html
2-为什么HashMap线程不安全
https://www.jianshu.com/p/e2f75c8cce01
3-hashmap死循环完美解析
https://www.jianshu.com/p/61a829fa4e49
4-死循环解析(推荐看这个比较详细，jdk1.7)
https://www.jianshu.com/p/13c650a25ed3
5-hashmap扩容原理(jdk1.8)
着重理解扩容后的索引变化逻辑，是否需要移动索引
https://blog.csdn.net/Yoga0301/article/details/84452104