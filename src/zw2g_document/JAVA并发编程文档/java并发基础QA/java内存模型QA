Q1:java内存模型是什么，它的定义是什么
A1:java内存模型也叫JMM，他定义的是线程和主内存之间的抽象关系，过程如下，线程执行方法，首先是java编译
器编译，jvm对编译后的字节码进行解释成指令，然后执行，执行的过程需要与内存进行数据的交互，整个过程就是线程
和主内存之间进行交互的过程,JMM就是对这个过程进行控制和抽象，塑造一个可控的内存模型,保证内存可见性

Q2:jmm是如何保证内存的可见性的
A2:JMM通过控制线程和内存的交互来保证内存的可见性，主要是通过禁止重排序和H-B原则
编译器重排序:JMM规则会禁止特定类型的编译器重排序
内存系统的重排序:现代的处理器往往通过使用寄存器或是写缓冲区临时保存向内存写入的数据，是的操作的顺序是混乱的
JMM通过在编译后的字节码中插入内存屏障，提供一致的内存可见性保证

Q3:jmm如何保证多线程的内存可见性问题
A3:为了提高效率，计算机在执行代码时，会进行编译器的重排序和处理器的重排序，对于多线程程序来说，如果无法保证
内存的可见行，那么将会影响到数据的正确性，对于重排序规则，jmm提供了两种控制手段
1jmm编辑器重排序规则会禁止一些编辑器进行重排序
2jmm处理器重排序规则则会在java进行编译过程中，在字节码中加入指定的内存屏障，用来禁止处理器的重排序


Q5:处理器为什么要对指令进行重排序，使用重排序为什么可以提升执行效率(内存系统重排序)
A5:现代处理器为了避免因为对总线内存过多的占用而导致的内存读写的延迟，以及为了避免处理器因为内存读写数据的延迟
而进行的等待，往往会使用写缓冲区，使用写缓冲区可以大大提高执行效率，那么使用写缓冲区对于内存的操作实际上与内存
本身的执行操作并不相同
假设a=b=0
需要执行的操作分别是a=1;x=b
通过写缓存区的处理器操作
A1为向写缓冲区写入a=1
A2为从内存中读取b
A3为将保存的数据刷新到总内存(此时才是将a的值真正写入到内存当中)
处理器操作顺序:写入a，读取b

内存的实际操作
A1:从内存中读取b
A2:将a=1写入内存
内存的操作顺序:读取b，写入a

此处可以发现，处理器因为使用写缓存区，使得与对内存的实际操作操作顺序不一致，但是却提升了效率，此处则是发生了重排序
关键词:写缓冲区，内存操作顺序

Q5-1:指令重排序
A5-1:


Q6:h-b与jmm之间的关系，如何建立起h-b关系
A6:h-b的本质则是jmm对程序员提供的跨线程的内存可见性的保障，简单的说，根据h-b规则，我们的程序在正确同步的多线程
中，程序编写在顺序的情况下，基于h-b原则，处理器不会对有可能影响到执行结果的代码顺序进行重排序
举个例子
volatile的写，h-b于读，意思就是，如果我们代码线进行了volatile修饰变量的写操作，那么对于处理器而言，则不会
进行读写之间指令的重排序，准确的说应该是在影响到最终执行效果的时候，处理器不会对这两个操作进行重排序操作
JMM基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行

重点1:只要两个操作之间存在h-b关系，无论是否发生重排序，都会保证前一操作的结果对后面操作可见
资料参考
理论说明
https://blog.csdn.net/liu_dong_liang/article/details/80391040
简单例子讲解
https://blog.csdn.net/u010031673/article/details/48153797


Q7:处理器与内存进行数据交换过程中的中间层
A7:数据在处理器与内存之间的交互是通过总线
处理器与内存对与数据对一系列交互属于总线事物，对于总线事物来说，会对请求它对事物进行同步操作
在处理器执行事物操作对过程中，是不允许其他处理器对内存进行读写操作


====================================理解===============================================
M1:对于happens-before的理解，happens-before与jmm的关系
happens-before是jmm最核心的概念，如果两个操作之前存在happens-before关系，这时候。jmm会针对操作之间
是否存在数据依赖关系来进行操作，如果操作之间不存在依赖关系，比如
a=1；
b=2；
这时候，jmm则会允许处理器或是编译器对这两个操作进行重排序操作
如果两个操作之间存在数据依赖关系，比如
a=1；
b=a；
这时候，jmm则不允许编译器或是处理器对操作进行重排序
对于程序员来说，我们看到对永远都是代码对顺序执行，而实际上，通过jmm，既保证了程序的内存可见行，又最大程度的
保证了编译器和处理器对程序的优化

h-b关系向jmm提交要求禁止违反h-b原则的重排序
如果重排序改变了执行结果，jmm则会禁止该重排序，否则不理会h-b提交的禁止要求
h-b关系的确立则是在指定的场景下
该操作的发生要求是单线程或正确同步的多线程


M2:
规则为如下三类
1-volatile写操作之前的所有操作不能进行重排序
2-volatile读操作之后的操作不能进行重排序
3-显示volatile写，再是volatile读，不能重排序

对于volatile的重排序规则，需要结合volatile的内存语意来分析
v写内存语意,jmm会将该线程对应本地内存的共享变量全部刷新到主内存中
结合分析规则1，如果v写和之前的操作发生重排序，那么实际数据可能只会被写入到缓存当中去而不会写入内存，那么其他数据
在读取值的时候从内存中拉取的数据就不是最新的，将会导致共享变量刷新到主内存的缺失，影响最终的结果

v读内存语意,JMM会将该线程对应的本地内存置为无效，从主内存中读取
结合v读内存语义,如果此时v读和普通读发生重排序，结果就是重排序后普通读读取的数据实际上可能是被缓存的数据，
而v读内存语义则保证了读取到的数据全部都是内存中的数据(缓存的数据会被更新)

volatile内存语义保证了读取到的数据都是内存中最新的数据，而不是缓存中的数据，保证了数据内存的可见性

volatile变量、happens-before与内存一致性错误:
https://blog.csdn.net/u014088294/article/details/52274269



M3:现代计算机通过使用缓存大大提高了执行效率，原因在于硬件对主线内存进行一次访问需要花费数百次时钟周期，
处理器通过使用缓存从数量级上大大降低了对内存访问延迟的成本，这些缓存通过对内存操作顺序的重新排序而大大提高了
计算机执行的性能



M4:对于重排序有两种，一种是编译器重排序，一种是运行期重排序
编译器重排序是编译期发生的重排序，目的是为了更好的适应CPU的并行操作
运行期重排序，CPU在执行指令的时候，通过对上下文的判断，对指令做重排序来进行优化
比如，当CPU对内存地址进行写入操作的时候，如果发现当前内存地址不可用，则会发生指令的重排序
内存屏障是控制重排序的手段




结语
关于并发基础，实际上就是对JMM的理解，JMM为程序员提供了一个看似顺序执行的程序环境，实际上是构造一个内存
模型,一方面满足计算机为了提升效率所作的优化，另一方面保障因为提升优化进行重排序带来的内存可见性的问题，保证了
单线程和正确同步的多线程的正确执行
