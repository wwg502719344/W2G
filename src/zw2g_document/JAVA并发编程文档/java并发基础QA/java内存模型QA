Q1:java内存模型是什么，它的定义是什么
A1:java内存模型也叫JMM，它定义了多线程和内存之间的关系，线程之间的共享变量存放在主内存当中，但是
每个线程都有属于自己的本地内存，但实际上所谓的本地内存并不是真实存在的，它往往代表的是计算机硬件
的缓存或是寄存器，甚至是编译器优化


Q2:jmm是如何保证内存的可见性的
A2:通过控制主内存和本地内存的交互来保证内存的可见性的，通过主内存和本地内存之间的数据交互，达到
本地数据的更新，保证本地数据的准确性，实现对于主内存的可见，所以通过控制主内存和本地内存的交互，
无论是获取数据还是写入数据，我们都可以得知别的线程对于共享数据的修改，掌握最新的内存数据，实现数据的可见


Q3:jmm如何保证多线程的内存可见性问题
A3:为了提高效率，计算机在执行代码时，会进行编译器的重排序和处理器的重排序，对于多线程程序来说，如果无法保证
内存的可见行，那么将会影响到数据的正确性，对于重排序规则，jmm提供了两种控制手段
1jmm编辑器重排序规则会禁止一些编辑器进行重排序
2jmm处理器重排序规则则会在java进行编译过程中，在字节码中加入指定的内存屏障，用来禁止处理器的重排序


Q4:重排序分类
A4:编译器重排序，指令集重排序，内存系统重排序


Q5:处理器为什么要对指令进行重排序，使用重排序为什么可以提升执行效率(内存系统重排序，非指令集重排序)
A5:现代处理器为了避免因为对总线内存过多的占用而导致的内存读写的延迟，以及为了避免处理器因为内存读写数据的延迟
而进行的等待，往往会使用写缓冲区，使用写缓冲区可以大大提高执行效率，那么使用写缓冲区对于内存的操作实际上与内存
本身的执行操作并不相同
假设a=b=0
需要执行的操作分别是a=1,x=b
通过写缓存区的处理器操作
A1为向写缓冲区写入a=1
A2为从内存中读取b
A3为将保存的数据刷新到总内存(此时才是将a的值真正写入到内存当中)
处理器操作顺序:写入a，读取b

内存的实际操作
A1:从内存中读取b
A2:将a=1写入内存
内存的操作顺序:读取b，写入a

此处可以发现，处理器因为使用写缓存区，使得与对内存的实际操作操作顺序不一致，但是却提升了效率，此处则是发生了重排序
关键词:写缓冲区，内存操作顺序


Q6:h-b与jmm之间的关系，如何建立起h-b关系
A6:h-b的本质则是jmm对程序员提供的跨线程的内存可见性的保障，简单的说，根据h-b规则，我们的程序在多线程执行的
情况下，程序编写在顺序的情况下，基于h-b原则，处理器不会对有可能影响到执行结果的代码顺序进行重排序
举个例子
volatile的写，h-b于读，意思就是，如果我们代码线进行了volatile修饰变量的写操作，那么对于处理器而言，则不会
进行读写之间指令的重排序，准确的说应该是在影响到最终执行效果的时候，处理器不会对这两个操作进行重排序操作
JMM基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行

资料参考
理论说明
https://blog.csdn.net/liu_dong_liang/article/details/80391040
简单例子讲解
https://blog.csdn.net/u010031673/article/details/48153797
