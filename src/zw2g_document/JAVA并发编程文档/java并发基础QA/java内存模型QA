Q1:java内存模型是什么，它的定义是什么
A1:java内存模型也叫JMM，它定义了多线程和内存之间的关系，线程之间的共享变量存放在主内存当中，但是
每个线程都有属于自己的本地内存，但实际上所谓的本地内存并不是真实存在的，它往往代表的是计算机硬件
的缓存或是寄存器，甚至是编译器优化


Q2:jmm是如何保证内存的可见性的
A2:通过控制主内存和本地内存的交互来保证内存的可见性的，通过主内存和本地内存之间的数据交互，达到
本地数据的更新，保证本地数据的准确性，实现对于主内存的可见，所以通过控制主内存和本地内存的交互，
无论是获取数据还是写入数据，我们都可以得知别的线程对于共享数据的修改，掌握最新的内存数据，实现数据的可见


Q3:jmm如何保证多线程的内存可见性问题
A3:为了提高效率，计算机在执行代码时，会进行编译器的重排序和处理器的重排序，对于多线程程序来说，如果无法保证
内存的可见行，那么将会影响到数据的正确性，对于重排序规则，jmm提供了两种控制手段
1jmm编辑器重排序规则会禁止一些编辑器进行重排序
2jmm处理器重排序规则则会在java进行编译过程中，在字节码中加入指定的内存屏障，用来禁止处理器的重排序


Q4:重排序分类
A4:编译器重排序，指令集重排序，内存系统重排序


Q5:处理器为什么要对指令进行重排序，使用重排序为什么可以提升执行效率(内存系统重排序，非指令集重排序)
A5:现代处理器为了避免因为对总线内存过多的占用而导致的内存读写的延迟，以及为了避免处理器因为内存读写数据的延迟
而进行的等待，往往会使用写缓冲区，使用写缓冲区可以大大提高执行效率，那么使用写缓冲区对于内存的操作实际上与内存
本身的执行操作并不相同
假设a=b=0
需要执行的操作分别是a=1,x=b
通过写缓存区的处理器执行操作
A1为向写缓冲区写入a=1
A2为从内存中读取b
A3为将保存的数据刷新到总内存

处理器对于内存的实际操作
A1:从内存中读取b
A2:将a=1写入内存

此处可以发现，处理器因为使用写缓存区，使得与对内存的实际操作操作顺序不一致，但是却提升了效率，此处则是发生了重排序
关键词:写缓冲区，内存操作顺序