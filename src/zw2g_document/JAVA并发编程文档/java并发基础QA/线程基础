线程是操作系统可以调度的最小单元，每一个线程都有自己的程序计数器，虚拟机栈，每一个线程都可以通过自己的本地内存与
总内存进行数据的交互和沟通，处理器在线程之间不停的切换

M1:线程的工作结构与jvm之间的关系
首先我们先确定线程的基本构造，那就是程序计数器和java虚拟机栈结构
程序计数器:
多线程的切换实际上是处理器在不同线程之间进行来回的切换，那么处理器就是通过计数器对每一个线程的位置进行记录，程序
计数器内部保存的是字节码指令地址，此处就可以理解为处理器下次需要在当前线程中需要执行的字节码指令的位置，可以理解
为行号指示器
java虚拟机栈:
线程私有的一块内存区域，生命周期与线程相同，每一个线程在调用方法的时候都会创建一个栈帧，栈帧就是虚拟机中执行方法
和保存局部变量的数据结构，栈帧中的局部变量表也就是我们常说的栈内存，线程的每一个方法都会创建一个栈帧
java栈帧:
当线程执行到java方法的时候，都会创建一个栈帧，栈帧中包括了局部变量表，操作数栈，动态调用，返回地址等
局部变量表:
编译期就已经确定大小了，实际就是栈内存，保存变量的临时数据
操作数栈:
这个是需要重点关注的，用于方法在运行时存放和获取操作数的栈空间，大小也是编译器就确定下来的，线程在执行一个方法
最初的时候，操作数栈是空的，方法执行过程中会不断的往操作数栈中进行入栈/出栈的操作，比如有一个相加的指令，这时候
会将两个操作数据压入到栈中，然后进行操作后在取出
动态链接-返回地址略过。。。

M2:线程执行逻辑
java代码->字节码指令->jvm虚拟机翻译
线程->创建虚拟机栈->创建栈帧，保存处理器执行指令过程中数据的交互及方法的调用

Q1:线程执行的是字节码指令还是JVM翻译后的指令
A1:处理器在执行jvm翻译后的指令，调用的是虚拟机栈帧中的方法和方法执行的数据结构,将指令产生的操作压入到操作数栈
中，并获取处理后的数据
Q2:java堆栈，局部变量表是什么
A2:java堆实际上就是我们说的堆内存，实际上就是用来保存对象数据的地方，也会jvm进行gc时候的主战场
java栈实际上就是指栈帧中的局部变量表，里面存放的是执行方法时候需要的变量数据或是对象饮用

M3:多线程的优先级是什么
需要注意的是，优先级高的线程并不代表会先执行，由于线程是处理器来回切换进行执行的，所以，线程的执行实际是cpu给到
每个线程的时间片，时间片也就意味着系统资源的分配，而优先级越高，意味着分配到的时间片越多

M4:线程的生命周期内主要有以下一些状态
NEW
BLOCK
RUNNABLE
WAITING
TIME_WAITING
TERMINATED

M5:理解线程间的等待通知模式
在现实多线程场景中，当我们线程a需要去修改对象的某个属性时，发现没有获取锁(对象锁被占据)，此时线程a被挂起等待通知，当获取锁的线程
b释放锁后，将会通知被挂起的线程a，此时线程a可以先获取锁，在对对象的属性进行修改，那么线程a和线程b之间的沟通，
则涉及到多线程之间的等待通知模式
需要注意的几个概念
等待队列
同步队列
wait，notify方法
线程的生命周期内有多种状态，通过调用相应的方法发生状态的转变，我通过消费生产模式来更好的解释线程通过状态转变
来进行多线程之间等待通知的沟通

在生产模式中，不断的往生产队列中添加任务，当有新当任务添加进队列时，调用notify方法唤醒等待处理任务的线程
在消费模式中，消费者获取任务进行消费，当发现任务队列为空时，将会让当前线程进入等待，等待生产者进行唤醒操作




