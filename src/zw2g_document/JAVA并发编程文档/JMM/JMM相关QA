Q1:两个线程调用一段代码，如何才能保证指令重排序导致执行的乱序

Q2:如果两个线程并发的访问了某个方法，那么相对应的这两个线程都会生成这两个方法的栈桢，
指令重排序是发生在这两个栈桢出栈前（在方法中进行重排序）还是出栈后，统一编译成指令集
在进行重排序执行

Q3:两个线程先后调用不同的方法，那么指令重排序会对两个不同方法的执行混在一起进行重排序吗

--------------------重点----------------------------重
Q4:hb原则到底保证了什么，在多线程情况下，他又可以保证什么？   |
--------------------重点----------------------------点

--------------------重点----------------------------重
Q5:什么是高并发编程，并行和并发的关系是什么？               |
--------------------重点----------------------------点

Q6:在hb原则中，volatile变量规则，先写在读，如果我确实要先读取，在写，那是不是违背hb原则了






A1:h-b原则严格保护多线程执行的内存可见性，涉及voilate修饰的变量，写一定发生在读的前面，
这样才能保证读数据的可靠性，在和同事的讨论中，我引入了栈桢的概念，实际上这种概念是错误的，
因为栈桢只针对一个线程的调用，在多线程的环境下，这种概念的引用是完全错误的，因为多线程就有
多个栈桢，这是毫无关联交集的两个东西

A2:...

A3:我认为是有可能的，首先基于栈桢的概念，压栈和出栈是有顺训的，在指令集里对应的就是两个命令
出栈后的代码应该是放在一个临界区中，临界区中的代码并不是按顺序执行，而是乱序执行，临界区的
代码会不断增加，但是临界区的代码维护h-b原则

A4:对于执行程序来说，编译器或是处理器为了提高执行效率，会对指令进行重排序，但是如果执行的程序
之间存在数据依赖关系，那么重排序的结果就会导致执行错误，这时候，hb原则就是为了保证程序的顺利执行
而存在的一种约定,hb原则并不是谁一定要在谁的前面执行，而是A hb B,那么A的执行结果一定要对B是可见的

关于线程执行的指令集，之前一直以为所谓的重排序是CPU对所有指令进行的一种重排，实际上每个线程都有自己的
CPU流水线，每次的重排序只会针对自己线程所有的操作，并不会将不同线程之间的指令放在一起进行重排序
hb原则并不是指执行的先后顺序，而是一种内存可见性

对于多线程下的HB原则，实际上保证的依旧是数据的可见性，假如在线程的操作或是关系之间存在hb的联系性，那么，hb
依旧会保证数据的可见性，例如普通变量之间，如果操作之间存在hb关系，那么对于普通变量之间的可见性依旧保证，
但是这完全不能保证程序执行的正确性
补充说明:
所谓的操作并不是指不同的线程，而是不同的两行执行代码，这两行执行代码可以是一个线程之内的，也可以是不同线程之间的
hb原则依然保证不同线程之间两个操作的内存可见性问题，JMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证！！！
（如果A线程的写操作a与B线程的读操作b之间存在happens-before关系，尽管a操作和b操作在不同的线程中执行，
但JMM向程序员保证a操作将对b操作可见）。

数据的可见性在多线程的情况下不代表程序执行的正确性！！！

参考资料：
http://ifeve.com/easy-happens-before/
https://blog.csdn.net/a1211529911/article/details/51496732

A5:大基调，并发是逻辑上的同时执行，并行是物理上的同时执行，是指能处理多个同时性的问题，
并发事件不一定在同一时间发生
并行是指同时进行的事情
并发指的是程序结构，并行指的是一种运行时的状态

参考资料:https://laike9m.com/blog/huan-zai-yi-huo-bing-fa-he-bing-xing,61/



