基础：
Q：ReentrantLock是轻量级锁(cas)还是偏向锁(再次获取锁不需要进行cas判断)，是如何实现的
A：实现了偏向锁的功能，在非公平获取同步状态的源码中，首先判断当前同步状态是否可获取，
如果可获取会判断持有者是否是自己，是自己的话，修改状态即可，不需要在进行cas的判断


Q：Lock和syn的主要区别
A：lock可以显示的获取和释放锁，syn不可以，lock实现锁机值的主要原理是通过cas进行
lock可以进行非阻塞的获取锁，可以超时或中断的获取锁


Q：同步组件的基本框架搭建原理
A：同步组件实现Lock接口，主要功能是获取锁的一系列方法，实现通过静态内部类，
静态内部类继承AQS，AQS通过模版方法(父类定义好代码逻辑，部分代码的具体实现交给子类来做)
静态内部类主要是实现AQS的模版方法，主要内容为获取同步状态的方法



源码：
======================================核心问题===========================================
Q:共享式获取和释放状态中头节点与同步状态获取的关系
A:共享式获取同步状态，根据相关状态，获取同步资源的过程从队首向队尾扩散的过程中，会逐步的传递头节点，但是
并不会释放同步状态，所以头节点始终只有一个，但是获取同步状态的节点却会有多个
======================================核心问题===========================================


Q：acquire方法中的acquireQueued是做什么的，selfInterrupt()是做什么的，什么时候触发，
A：acquireQueued方法是将未获取同步状态的节点加入到同步队列中去，无限循环直到获取同步状态
acquireQueued：
shouldParkAfterFailedAcquire是检测前驱节点是否是signal状态以便安心挂起
parkAndCheckInterrupt，标记是否被中断过并继续阻塞
如果曾经被中断过，记录，当获取资源后，selfInterrupt()进行中断，队列本身不响应中断


Q:共享锁获取资源后，首节点怎么设置，共享状态怎么设置
A:在调用tryAcquireShared方法的时候，执行该方法的线程直接获取状态成功，所以不需要排队，没有首节点


Q:tryAcquireShared(arg)中首节点的设置和释放在哪里
A:当线程未加入同步队列中执行该方法时，不存在首节点，因为没有加入队列
当首次获取失败后加入队列，这时再次获取成功就设为首节点

Q:在自旋过程中被唤醒的结点，会进行什么操作，在哪里进行，调用了什么方法
NA:书上只是说被唤醒的线程会进行自我检查，但也没说在哪里进行自我检查，调用什么方法，
自己也没找到，等找到原因了再来填坑吧
猜测是每个线程都会调用获取锁的方法，当被唤醒的时候，会在acquireQueued方法中if (p == head && tryAcquire(arg))判断

Q:如果头节点没有进行对后继节点的唤醒操作，那么在后继节点的自旋过程中，发现了前驱是头节点，就不会进行cas操作了吗


