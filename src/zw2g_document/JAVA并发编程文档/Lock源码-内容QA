基础：
Q：ReentrantLock是轻量级锁(cas)还是偏向锁(再次获取锁不需要进行cas判断)，是如何实现的
A：实现了偏向锁的功能，在非公平获取同步状态的源码中，首先判断当前同步状态是否可获取，
如果可获取会判断持有者是否是自己，是自己的话，修改状态即可，不需要在进行cas的判断


Q：Lock和syn的主要区别
A：lock可以显示的获取和释放锁，syn不可以，lock实现锁机值的主要原理是通过cas进行
lock可以进行非阻塞的获取锁，可以超时或中断的获取锁


Q：同步组件的基本框架搭建原理
A：同步组件实现Lock接口，主要功能是获取锁的一系列方法，实现通过静态内部类，
静态内部类继承AQS，AQS通过模版方法(父类定义好代码逻辑，部分代码的具体实现交给子类来做)
静态内部类主要是实现AQS的模版方法，主要内容为获取同步状态的方法

源码：
Q：acquire方法中的acquireQueued是做什么的，selfInterrupt()是做什么的，什么时候触发，
A：acquireQueued方法是将未获取同步状态的节点加入到同步队列中去，无限循环直到获取同步状态
acquireQueued：
shouldParkAfterFailedAcquire是检测前驱节点是否是signal状态以便安心挂起
parkAndCheckInterrupt，标记是否被中断过并继续阻塞
如果曾经被中断过，记录，当获取资源后，selfInterrupt()进行中断，队列本身不响应中断


Q:共享锁获取资源后，首节点怎么设置，共享状态怎么设置
A:在调用tryAcquireShared方法的时候，执行该方法的线程直接获取状态成功，所以不需要排队，没有首节点